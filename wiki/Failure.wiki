#summary Flow control

= Introduction =

Has to be seen first the similitude between the try/throw/catch system of most languages and the C-like {{{&&}}} operator.
For the C-like {{{&&}}} operator, the _first false value_ leads the complete condition to stop evaluating.

The failure is a kind of _meta-false_. All your expression leads to a value or a failure - here are the meta _true_ and _false_.

This implemented as an exception in the !JavaScript interpreter.

= Throwing the failure =

The failure can be triggered by three kind of non-met constraints :
 * The unification constraints. If two elements has to be unifiable but don't fit, it will lead to a failure.
 * The appartenance constraints.
 * The ordering constraints.

= Catching a failure =

A failure is caught in two cases :
== In the definition of a set ==
The set then result a an empty set but doesn't fail.

For instance, the set of all integers smaller than 3 and bigger than 5 {{{ {Z x ? x > 5 & x < 3} }}} just lead to an empty set - while the condition fails.
It would be the same for the set of all the 'ones' that are unifiable to any 'twos' : {{{ {1 = 2} }}} : there is only one 'one' and it cannot be unified to the only one 'two' : the set is empty.

Note:
 * The {{{ {Z x ? x > 5 & x < 3} }}} set will not be understood as "the empty set {}" and can still carry its whole definition with if the solving engine doesn't help - it will still fail on each element taking and, therefore, has the exact same behaviour as the empty set.
 * {{{ {} }}} is the shortcut to write "empty set"

== In an element of a _meta-OR_ ==

An element of an OR that fails is just removed from the list of possibilities.
Writing {{{ 1=2 [] a [] b }}} is exactly the same as {{{ a [] b }}}