#summary Engine used to get precise answers out of an expression

= Introduction =

The solving engine is the one that would take an expression and, for a picture, "get down the greedy-OR-s to the root". So, to take a generic expression and enumerate all its precise (and not fuzzy) possible values.

for example : {{{( 1 [] 2 ) , ( 3 [] 4 )}}} : the pair that begins by one or two and end by three or four, can have four values : 
|| {{{(1, 3)}}}||{{{(1, 4)}}}||{{{(2, 3)}}}||{{{(2, 4)}}}||

= Comparisons =

Compared to prolog 'solving engine' (while there is no such thing in prolog, solving is made while evaluation), the NUL solving engine don't give an answer and wait for a key press : it gives all the possibilities at once. This means that an infinite set of possibilities will give only the one generic answer instead of all.

= How does it work? =

The principle of the solving engine is to take a fuzzy expression, to spot a place of fuzzyness (a greedy-or for instance) and then, to try to evaluate the whole expression replacing the fuzzy value sequentially by each precise values this fuzzy spot can take.
If the expression contains {{{ 1 [] 2 }}}, the solving engine will replace the occurence of {{{ 1 [] 2 }}} by {{{ 1 }}}, try to solve the whole expression again, then do the same but replacing by {{{ 2 }}}.

= The one implemented now =

For now, the solving engine is really basic : it just take the first greedy-or it finds and enumerate every possible values.
Later, it will have to be :
 * completed : there are other fuzzy expressions than the greedy-or (like the content-or for instance) that will have to be solved as well.
 * optimised : there is a way to choose a better greedy-or than the first encountered to browse more cases quicker.