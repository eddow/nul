Imperative languages often have two logic level. For instance, there are two "and"s : " & " and " && ".
Affirmative languages have a third logic level; Called here a "meta-level"

Usually, they keep this third level as a boolean value (working or not). For instance, in SQL, the row is kept or not. In NUL, it is tryed the way where, when it "is working", then it has a value.

If we take back the unification process, " a = 2; a = 3 " means that "a" is 2 and then that "a" is 3. In affirmatives languages like NUL, this fails.
It has the exact same meaning as " 2 = 3 " : as everything is knowledge expression; if you express "I know that 2 is equivalent to 3 ", then the NUL kernel will express " It doesn't work ".

A failure can just be seen as an imperative language "exception" (and, in the javascript interpreter, is implemented as an exception)

So that the point of NUL, once you gave him all the knowledge you have, is to tell you the result of the knowledge (for instance, if you know "5 + 7", NUL can say that you know "12") or the fact that the knowledge means to something inconsistent : that it doesn't work : failure.