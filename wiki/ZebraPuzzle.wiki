#summary Traditional Lewis Carol's zebra puzzle
#labels program
= Introduction =

Enigma (from [http://en.wikipedia.org/wiki/Zebra_Puzzle wikipedia])
 # There are five houses.
 # The Englishman lives in the red house.
 # The Spaniard owns the dog.
 # Coffee is drunk in the green house.
 # The Ukrainian drinks tea.
 # The green house is immediately to the right of the ivory house.
 # The Old Gold smoker owns snails.
 # Kools are smoked in the yellow house.
 # Milk is drunk in the middle house.
 # The Norwegian lives in the first house.
 # The man who smokes Chesterfields lives in a house next to the man with the fox.
 # Kools are smoked in a house next to the house where the horse is kept.
 # The Lucky Strike smoker drinks orange juice.
 # The Japanese smokes Parliaments.
 # The Norwegian lives next to the blue house.
Now, who drinks water? Who owns the zebra?

This enigma is especially the kindof problems that declarative languages aim to resolve : knowledge is described, a snap-shot situation is given (no evolution, affectaion, ...).

= NUL zebra =

{{{
"The zebra belongs to the " + zebraOwner + " and water is drunk by the " + waterDrinker
; S(_,_,zebraOwner,_,"zebra",_)
; S(_,_,waterDrinker,_,_,"water")

; ld={ 0 :- {} [] (N n) :- ((n, _, _, _, _, _) ,.. ld (n-1)) }
; S = ld 5

; S(_,"red","english",_,_,_)
; S(_,_,"spaniard",_,"dog",_)
; S(_,"green",_,_,_,"coffee")
; S(_,_,"ukrainian",_,_,"tea")
; { S(n+1,"green",_,_,_,_); S(n, "ivory",_,_,_,_) } _
; S(_,_,_,"Old Gold","snails",_)
; S(_,"yellow",_,"Kools",_,_)
; S(3,_,_,_,_,"milk")
; S(1,_,"norwegian",_,_,_)
; {S(n,_,_,"Chesterfields",_,_); S((n-1[]n+1),_,_,_,"fox",_)} _
; {S(n,_,_,"Kools",_,_); S((n-1[]n+1),_,_,_,"horse",_)} _}}}
; S(_,_,_,"Lucky Strike",_,"orange juice")
; S(_,_,"japanese","Parliaments",_,_)
; { S(n,_,"norwegian",_,_,_); S((n-1[]n+1),"blue",_,_,_,_) } _
}}}

= Description =

The first three lines give the shape of the result: a string showing {{{zebraOwner}}} and {{{waterDrinker}}}, while describing what these unknowns stand for.

The {{{ld}}} auxiliary describe the shape of the solution :
The variable S is the "solution" : it contains five 6-uples. Each 6-uples is " number, colour, nationality, smoked, animal, drunk "
The set S contains the five entities.

The remaining lines are the clues.

The first can be red as _The solution set S contains an entity where nationality is "english" and colour is "red"_.

Some clues speak about house proximity. It then specifies a number ({{{N}}} stands for "natural") {{{n}}} and its neighbour, either {{{n+1}}} for "the house at the right" or {{{n+1 [] n-1}}} for "a neighbour".

= Progress =

Are not expressed here :
 * nations, smokings, animals, colors and drinks are all different
Indeed, this specification is not needed.

Now, this program solves but this NUL-optimised program :
{{{
S
; ld={ 0 :- {} [] (N n) :- ((n, _, _, _, _, _) ,.. ld (n-1)) }
; S = ld 5

; S(1,_,"norwegian",_,_,_)
; S(3,_,_,_,_,"milk")

; S(_,"red","english",_,_,_)
; S(_,_,"spaniard",_,"dog",_)
; S(_,"green",_,_,_,"coffee")
; S(_,_,"ukrainian",_,_,"tea")
; { S(n+1,"green",_,_,_,_); S(n, "ivory",_,_,_,_) } _
; { S(n,_,"norwegian",_,_,_); S((n-1[]n+1),"blue",_,_,_,_) } _

; S(_,_,"japanese","Parliaments",_,_)
; S(_,"yellow",_,"Kools",_,_)
; S(_,_,_,"Lucky Strike",_,"orange juice")

; S(_,_,_,"Old Gold","snails",_)
; {S(n,_,_,"Chesterfields",_,_); S((n-1[]n+1),_,_,_,"fox",_)} _
; {S(n,_,_,"Kools",_,_); S((n-1[]n+1),_,_,_,"horse",_)} _
}}}
 * another step will be to optimise it even if the zebra program is not given optimised : this is about choosing another algorithm for the SolvingEngine
 * This new version is under test now