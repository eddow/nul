#summary Attributes and Object Oriented writing.
#labels Language

= Introduction =

Values can be given attributes to access some of their characteristics.

A lot of imperative object-oriented programming concepts have to be reviewed though. For instance, from the "unification" point of view, getters and setters are the same. Beside it, the "length computation" is not anymore a method : if a string has a value, it won't change and the length is a value ... and can even be a setter.

= Syntax =

*::*_attr1_*(* {{{[attribute1]}}} *)* *::*_attr2_*(* {{{[attribute2]}}} *)* ...

Where items between brackets are standard NUL expressions.

If an expression has a named attribute, it can be used with the {{{->}}} operator as in most languages (the right operand must therefore be an identificator).

== Example ==

{{{
C = {
::rl(Q r )
::img(Q i)
::sq(r*r+i*i)
}
}}}

Note: {{{sq}}} stands for "square modulo" while there is no math library implemented to take the square root yet.

There is no such things as the "this" keyword : the attributes declarations access directly the values used in the internal represention. Only locals can be accessed from the definition : some could see the locals {{{r}}} and {{{i}}} as the private values and the accessors {{{rl, img, sq}}} as public values.

This is not a limitation, this have been choosen this way! If it is needed to access attributes declared after, this means there is recursivity. It has therefore to be written this way, as an [AutoReferences auto-reference].

This means, in english that,
 * for any rational numbers {{{a}}} and {{{b}}},
 * a complex number has
  * a real part {{{rl}}}, that is a rational number (here named {{{r}}}),
  * an imaginary part {{{img}}}, that is a rational number (here named {{{i}}}),
  * a square modulo that is the sum of the square of the real part and the square of the imaginary part.

= Classes and instances =

As most of the concepts, classes in NUL are just _sets_ of values, like the complex class just defined above.