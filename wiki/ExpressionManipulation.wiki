#summary Basic expression manipulations functionnalities
#labels Phase-Implementation

= Introduction =

The expressions, in order to be evaluated, to give a computed result instead of the half-computed expression given, will have to go through several transformations


= By expression type =

== FuzzyExpressions ==

Fuzzy expressions can undergo these modifications, that apply to the values and premices.
 * *Simplification*: All the expressions that are in an _equivalence class_ are replaced by the _equivalence class stereotype_

ex: {{{x + 2 ; 3 = x}}}  becomes {{{3 + 2 ; 3 = x}}}

 * *Relocation*: 'Local index-space defragmentation'. If the fuzzy expression use 5 locals but effectively use only number 2 and 4, local number 2 is 'renamed' (in sub-expressions) as local number 0, number 4 is renamed as number 1 and the fuzzy expressions knows to use only two locals.

 * *Concentration*: removal of orphan premices. An orphan premice is a premice about a local where the local is only used in the premice. _Concentration_ also remove orphan equivalence elements.

ex: {{{x + 2 ; 3 = x = y}}}  becomes {{{x + 2 ; 3 = x}}}

 * *Reformulation*: After some modification, the premices can contain premices that give a computed result once taken all together. It isa kind of premice-evaluation.

ex: {{{x ; 3 = x ; 2 = x}}} fails
ex: {{{y ; 3 = x ; x = y}}} gives {{{y; 3 = x = y}}}

 * *Subjectivisation*: The object item-taking are replaced by the token item. Here, the 'types' are used to have a resoluted object item instead of the objectivity.

ex: {{{ x + y ; Q x ; Q y }}} becomes {{{ (nbr+nbr x) y ; Q x ; Q y }}} where `nbr+nbr` is
the internal (!JavaScript) function of number addition.

== [Sets] ==

 * *Resolution*: remove all IOR3 expressions from a set for the set definition to be the only choice-list. Note: it doesn't remove IOR3 from sub-sets.

ex: {{{ { 1 + (2 [] 3) } }}} becomes {{{ { (1 + 2) [] (1 + 3) } }}}

== [Unification]s ==

 * *Application*: If possible, try to unify sub-elements; try to take the inverse function ({{{5 = function x}}} takes `inv_function` of `5`) or such.
All the un-evaluable unifications (like {{{x = y}}}) are just added to the present knowledge.

== [TakeExpression]s ==
TODO: no more 'take', just 'value of*' and belonging assertion
 * *Application*: If possible, replace the application by the result. If not, add the take-expression in the knowledge.

ex: {{{ double 5 }}} is computed as  {{{ 5 * 2 }}}