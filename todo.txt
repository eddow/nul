next = { \/x {x} => {}
[] (a, b,..o) => ((a=>b),.. next(b,.. o))
}

:::cas "s s" set auto-inclusive : s is protected while representing ... so what happen ?

(set s) x ==> s x
set
={ {}
[]  (a,.. s) => ( set s [] (a,.. set s) )
}
:::faire!

\/inOrder
{ (inOrder [1..2]) _ [] (t,v); (inOrder [1..2])(v,t) }
; inOrder = { \/x {x} => {} [] (a,b,.. o) => ((a,b),.. inOrder(b,.. o)) }

::: donne des résultats ><


f = { x = f x }
::: Ca devrait donner l'identité, pas le gros truc complexe

neighbours
; S = [1..2]
; inOrder = { \/x {x} => {} [] (a,b,.. o) => ((a,b),.. inOrder(b,.. o)) }
; neighbours = { (inOrder S) _ [] (t,v); (inOrder S)(v,t) }
::: Une locale perd son nom !


::: boucle infini ><
inOrder S
; S = houses [1..5]
; houses = { {} [] (n,.. ns) =>  ((_::number n),.. houses ns) }
; inOrder = { \/x {x} => {} [] (a,b,.. o) => ((a,b),.. inOrder(b,.. o)) }

((inOrder S) _) [] ((t,v); (inOrder S)(v,t))
; inOrder = { \/x {x} => {} [] (a,b,.. o) => ((a,b),.. inOrder(b,.. o)) }
::: boucle infini ><

todo {
inOrder [1..]			//inf decomposition
\/a { _ ::attr a } a	//attribute self-ref 
}


S = houses [1..5]
; houses = { {} [] (n,.. ns) =>  (_::number n),.. houses ns }

S = (_ ::number 1,_ ::number 2,_ ::number 3,_ ::number 4,_ ::number 5)
; inOrder = { \/x {x} => {} [] (a,b,.. o) => ((a,b),.. inOrder(b,.. o) ) }
; neighbours = { (inOrder S) _ [] (a, b); (inOrder S)(b,a) }
; S(_ ::number 3 ::drink "milk")
; S(_ ::number 1 ::nation "norwegian")
; S(_ ::color "red" ::nation "english")
; S(_ ::nation "spaniard" ::animal "dog")
; S(_ ::nation "ukrainian" ::drink "tea")
; S(_ ::nation "japanese" ::smoke "Parliaments")
; S(_ ::color "green" ::drink "coffee")
; S(_ ::smoke "Lucky Strike" ::drink "orange juice")
; S(_ ::smoke "Old Gold" ::animal "snails")
; S(_ ::color "yellow" ::smoke "Kools")
; (inOrder S)(_ ::color "green", _ ::color "ivory")
; neighbours(_ ::smoke "Kools", _ ::animal "horse")
; neighbours(_ ::smoke "Chesterfields", _ ::animal "fox")
; neighbours(_ ::nation "norwegian", _ ::color "blue")
