si eqCls contient ior3 qui depend d'une locale, ne considerera pas qu'un elem de l'ior3 peut etre absolu (par ex)

\/sigma \/S
{ (a, b); ((a=sigma[S][b]) [] (b=sigma[S][a])) } = oiuoiu
; S = houses [1..5]
; houses = { {} => {} [] (n,.. ns) => ((_::number n),.. houses[ns]) }
; sigma ={ \/x {x} => {} [] (a,b,.. o) => ((a=>b),.. sigma[b,.. o] ) }
::: virer le oiuoiu pour que ca marche ........

:::cas "s s" set auto-inclusive : s is protected while representing ... so what happen ?

x 1
; set[1..3] x
; set
={ {}
[] \/a \/s (a,.. s) => ( set[s] [] (a,.. set[s]) )
}
:::faire! (developper)



todo {
sigma[1..]			//inf decomposition
}

S = houses [1..5]
; houses = { {} => {} [] (n,.. ns) => ((_::number n),.. houses[ns]) }
; sigma ={ \/x {x} => {} [] (a,b,.. o) => ((a=>b),.. sigma[b,.. o] ) }
; neighbours = { (a, b); (a=sigma[S][b] [] b=sigma[S][a])}
; S(_ ::number 3 ::drink "milk")
; S(_ ::number 1 ::nation "norwegian")
; S(_ ::color "red" ::nation "english")
; S(_ ::nation "spaniard" ::animal "dog")
; S(_ ::nation "ukrainian" ::drink "tea")
; S(_ ::nation "japanese" ::smoke "Parliaments")
; S(_ ::color "green" ::drink "coffee")
; S(_ ::smoke "Lucky Strike" ::drink "orange juice")
; S(_ ::smoke "Old Gold" ::animal "snails")
; S(_ ::color "yellow" ::smoke "Kools")
; sigma[S][_ ::color "green"] = (_ ::color "ivory")
; neighbours(_ ::smoke "Kools", _ ::animal "horse")
; neighbours(_ ::smoke "Chesterfields", _ ::animal "fox")
; neighbours(_ ::nation "norwegian", _ ::color "blue")
